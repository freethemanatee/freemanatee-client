package me.zopac.freemanatee.module.modules.exploits;

import java.awt.*;
import java.awt.event.*;

import me.zopac.freemanatee.command.Command;
import me.zopac.freemanatee.module.Module;
import me.zopac.freemanatee.setting.Setting;
import me.zopac.freemanatee.setting.Settings;
import net.minecraft.network.play.server.SPacketChunkData;
import me.zero.alpine.listener.Listener;
import me.zero.alpine.listener.EventHandler;
import me.zopac.freemanatee.event.events.PacketEvent;
import me.zopac.freemanatee.util.WorldUtils;

import net.minecraft.entity.passive.EntityDonkey;
import net.minecraft.entity.Entity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.InputUpdateEvent;
import net.minecraftforge.fml.common.ObfuscationReflectionHelper;
import net.minecraft.item.ItemStack;
import net.minecraft.inventory.ClickType;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.passive.*;
import net.minecraft.util.NonNullList;
import net.minecraft.inventory.ContainerHorseChest;
import net.minecraft.inventory.InventoryBasic;


@Module.Info(name="AutoDismountDupe", category=Module.Category.EXPLOITS)
public class AutoDismountDupe extends Module {

     private Setting<Boolean> debug = this.register(Settings.b("Debug Mode", false));
     private Setting<Boolean> loop = this.register(Settings.b("Loop Mode", false));
     private Setting<Integer> wait = this.register(Settings.integerBuilder("Hopper Wait").withMinimum(1).withValue(10).withMaximum(10000).build());

     private int length;
     private int delay;

     private float yaw;

     private double initX;
     private double initZ;
     private double goalX;
     private double goalZ;
     private double lastX;
     private double lastZ;

     private boolean atEnd;
     private boolean packetSent;
     private boolean shouldMove;
     private boolean firstRun;
     private boolean runComp;
     private boolean initMove;

     public BlockPos finalPos;
     public EntityDonkey donkey;
     public EnumFacing face;
     public Robot r;
     public KeyEvent k;

     @Override
     protected void onEnable() {
         if (mc.world == null) {
             this.disable();
             return;
         }

         this.initMove = true;
         this.runComp = false;
         this.firstRun = true;
         this.atEnd = false;
         this.length = 8;
         this.delay = 0;
         this.shouldMove = false;

         getFace();
         this.goalX = getGoalX();
         this.goalZ = getGoalZ();
         clampYaw();
         this.yaw = mc.player.rotationYaw;
         this.initX = mc.player.posX;
         this.initZ = mc.player.posZ;

         finalPos = new BlockPos(this.goalX, mc.player.posY, this.goalZ);

         try {
             r = new Robot();
         } catch (Exception e) {
             Command.sendChatMessage("Restart please");
             this.disable();
         }

         getCoords();
     }

     @EventHandler
     private Listener<PacketEvent.Receive> packetEventReceiveListener = new Listener<PacketEvent.Receive>(event -> {
         if (this.isDisabled() || mc.player == null) {
             return;
         }
         if (event.getPacket() instanceof SPacketChunkData) {
             if (this.atEnd) {
                 this.packetSent = true;
             }
         }
     });

     @EventHandler
     private Listener<InputUpdateEvent> inputUpdateEventListener = new Listener<>(event -> {
         if (this.shouldMove) {
             event.getMovementInput().moveForward = 1;
         }
     });

     public void getCoords() {
         if (this.debug.getValue()) {
             Command.sendChatMessage("End x: " + this.goalX + " End z: "+this.goalZ);
             Command.sendChatMessage("Facing: " + face.getName());
             Command.sendChatMessage("Yaw: " + mc.player.rotationYaw);
         }
     }

     @Override
     public void onUpdate() {
         if (mc.player == null || this.isDisabled()) {
             return;
         }
         if (!mc.playerController.isRidingHorse() && this.initMove == true) {
             getDonkey();
             getOnDokey();
             return;
         }
         if (mc.playerController.isRidingHorse()) {
             if (this.initMove) {
                 runStartCommands();
                 this.shouldMove = true;
                 this.initMove = false;
             }
         }
         if (this.runComp) {
             if (this.delay > this.wait.getValue()) {
                 Command.sendChatMessage("done");
                 r.keyPress(KeyEvent.VK_U);
                 r.keyRelease(KeyEvent.VK_U);
                 // throwItems();
                 this.disable();
                 if (this.loop.getValue()) {
                     getOnDokey();
                     r.keyPress(KeyEvent.VK_SHIFT);
                     r.keyRelease(KeyEvent.VK_SHIFT);
                 }
                 return;
             }

         } else {
             mc.player.rotationYaw = this.yaw;
             if (this.atEnd) {
                 Command.sendChatMessage("at end");
                 if (this.firstRun) {
                     Command.sendChatMessage("is first run");
                     if (this.packetSent || this.delay > 250) {
                         Command.sendChatMessage("packet sent");
                         // reloadChunks();
                         this.firstRun = false;
                         this.atEnd = false;
                         this.packetSent = false;
                         this.yaw += 180;
                         mc.player.rotationYaw = this.yaw;
                         this.goalX = this.initX;
                         this.goalZ = this.initZ;
                         this.initX = mc.player.posX;
                         this.initZ = mc.player.posZ;
                         face = getFace();
                         getCoords();
                         this.shouldMove = true;
                         return;
                     }
                     this.delay++;
                 } else {
                     this.shouldMove = false;
                     runEndCommands();
                     return;
                 }
             }
             isPastCoords();
         }
     }

     public void clampYaw() {
         if (face == EnumFacing.NORTH) {
             mc.player.rotationYaw = 180;
         }
         else if (face == EnumFacing.SOUTH) {
             mc.player.rotationYaw = 0;
         }
         else if (face == EnumFacing.WEST) {
             mc.player.rotationYaw = 90;
         }
         else {
             mc.player.rotationYaw = -90;
         }
     }

     public double getGoalX() {
         if (face == EnumFacing.SOUTH || face == EnumFacing.NORTH) {
             return mc.player.posX;
         } else if (face == EnumFacing.EAST) {
             return mc.player.posX + this.length*16;
         } else if (face == EnumFacing.WEST) {
             return mc.player.posX - this.length*16;
         } else {
             return mc.player.posX;
         }
     }

     public double getGoalZ() {
         if (face == EnumFacing.EAST || face == EnumFacing.WEST) {
             return mc.player.posZ;
         } else if (face == EnumFacing.SOUTH) {
             return mc.player.posZ + this.length*16;
         } else if (face == EnumFacing.NORTH) {
             return mc.player.posZ - this.length*16;
         } else {
             return mc.player.posZ;
         }
     }

     public EnumFacing getFace() {
         boolean isNegative = false;
         this.yaw = mc.player.rotationYaw;
         if (this.yaw < 0) { // if yaw is negative flip the x
             isNegative = true;
         }
         int dir = (int) Math.round(Math.abs(this.yaw)) % 360; // yet the magnatude of the player's direction

         if (135 < dir && dir < 225) { // if looking south
             face = EnumFacing.NORTH;
         } else if (225 < dir && dir < 315) { // if looking west
             if (isNegative) {
                 face = EnumFacing.WEST;
             } else {
                 face = EnumFacing.EAST;
             }
         } else if (45 < dir && dir < 135) { // if looking east
             if (isNegative) {
                 face = EnumFacing.EAST;
             } else {
                 face = EnumFacing.WEST;
             }
         } else { // if looking north
             face = EnumFacing.SOUTH;
         }
         return face;
     }

     public void isPastCoords() {
         if (face == EnumFacing.NORTH) {
             if (this.initZ < this.goalZ) {
                 if (!this.atEnd && Math.round(mc.player.posZ) >= this.goalZ) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
             if (this.initZ > this.goalZ) {
                 if (!this.atEnd && Math.round(mc.player.posZ) <= this.goalZ) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
         } else if (face == EnumFacing.EAST) {
             if (this.initX < this.goalX) {
                 if (!this.atEnd && Math.round(mc.player.posX) >= this.goalX) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
             if (this.initX > this.goalX) {
                 if (!this.atEnd && Math.round(mc.player.posX) <= this.goalX) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
         } else if (face == EnumFacing.WEST) {
             if (this.initX < this.goalX) {
                 if (!this.atEnd && Math.round(mc.player.posX) >= this.goalX) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
             if (this.initX > this.goalX) {
                 if (!this.atEnd && Math.round(mc.player.posX) <= this.goalX) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
         } else if (face == EnumFacing.SOUTH) {
             if (this.initZ < this.goalZ) {
                 if (!this.atEnd && Math.round(mc.player.posZ) >= this.goalZ) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
             if (this.initZ > this.goalZ) {
                 if (!this.atEnd && Math.round(mc.player.posZ) <= this.goalZ) {
                     this.atEnd = true;
                     this.shouldMove = false;
                 }
             }
         }
     }

     public void throwItems() {
         final Entity ridingEntity = mc.player.getRidingEntity();
         if (ridingEntity != null && ridingEntity instanceof AbstractHorse) {
             final AbstractHorse horse = (AbstractHorse)ridingEntity;
             final ContainerHorseChest horseChest = (ContainerHorseChest)ObfuscationReflectionHelper.getPrivateValue((Class)AbstractHorse.class, (Object)horse, new String[] { "horseChest", "field_110296_bG" });
             final NonNullList<ItemStack> horseItems = (NonNullList<ItemStack>)ObfuscationReflectionHelper.getPrivateValue((Class)InventoryBasic.class, (Object)horseChest, new String[] { "inventoryContents", "field_70482_c"});
             System.out.println(horseItems.toString());
             for (int i = 0; i < mc.player.inventory.getSizeInventory(); ++i) {
                 System.out.println("Dropping item in slot: " + i);
                 mc.playerController.windowClick(mc.player.openContainer.windowId, i, 0, ClickType.THROW, (EntityPlayer)mc.player);
             }
         }
         this.setEnabled(false);
     }

     public void takeDonkeyItems() {
         r.keyPress(KeyEvent.VK_E);
         r.keyRelease(KeyEvent.VK_E);
         this.runComp = true;
     }

     public void getOnDokey() {
         BlockPos pos = new BlockPos(donkey.posX+0.5, donkey.posY-1, donkey.posZ+0.5);
         WorldUtils.lookAtBlock(pos);
         r.mousePress(InputEvent.BUTTON3_DOWN_MASK);
         r.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);
     }

     public void runStartCommands() {
         mc.player.sendChatMessage(".entitydesync dismount");
         r.keyPress(KeyEvent.VK_U);
         r.keyRelease(KeyEvent.VK_U);
     }

     public void runEndCommands() {
         mc.player.sendChatMessage(".entitydesync remount");
         takeDonkeyItems();
     }

     public void reloadChunks() {
         r.keyPress(KeyEvent.VK_F3);
         r.keyPress(KeyEvent.VK_A);
         r.keyRelease(KeyEvent.VK_A);
         r.keyRelease(KeyEvent.VK_F3);
     }

     public boolean getDonkey() {
         for (Entity ent : mc.world.loadedEntityList) {
             if (ent instanceof EntityDonkey) {
                 donkey = (EntityDonkey) ent;
                 return true;
             }
         }
         return false;
     }
 }